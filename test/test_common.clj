(ns test_common)

(defn- assert_ [loc expected actual]
  (if (not (assert expected actual))
    (FIXME loc " - " expected " != " actual)))

(defn- assert_not [loc expected actual]
  (if (assert expected actual)
    (FIXME loc " - " expected " == " actual)))

(defn- ?!- [x] x)
(def- static_field "123")

(defn test []
  (assert_ __LOC__ "123" static_field)
  (assert_ __LOC__ 7 (inc 6))
  (assert_ __LOC__ 3 (:a (update {:a 2} :a (fn [x] (inc x)))))
  (assert_ __LOC__ 7 (/ 21 3))
  (assert_ __LOC__ 21 (* 3 7))
  (assert_ __LOC__ 6 (+ 1 2 3))
  (assert_ __LOC__ 2 (- 7 5))
  (assert_ __LOC__ 1 (mod 3 2))
  (assert_ __LOC__ false (not true))
  (assert_ __LOC__ true (not false))
  (assert_ __LOC__ true (> 2 1))
  (assert_ __LOC__ false (> 2 2))
  (assert_ __LOC__ true (>= 2 2))
  (assert_ __LOC__ false (>= 2 3))
  (assert_ __LOC__ true (< 1 2))
  (assert_ __LOC__ false (< 2 2))
  (assert_ __LOC__ true (<= 2 2))
  (assert_ __LOC__ false (<= 3 2))
  (let [{ma :a mb :b} {:a 1 :b 2 :c 3}]
    (assert_ __LOC__ "12" (str ma mb)))
  (let [value_atom (atom 1)]
    (assert_ __LOC__ 1 (swap! value_atom (fn [^int x] (+ x 2))))
    (assert_ __LOC__ 3 (deref value_atom)))
  (assert_ __LOC__ 1 (?!- 1))
  (assert_ __LOC__ [] (filter (fn [_] false) [1 2]))
  (assert_ __LOC__ ["1" "2"] (map (fn [x] (str x)) [1 2]))
  (assert_ __LOC__ 1 (if (clojure.string/ends-with? "foo.txt" ".txt") 1 2))
  (assert_ __LOC__ 2 (if (clojure.string/ends-with? "foo.bin" ".txt") 1 2))
  (assert_ __LOC__ "hello world" (clojure.string/replace "hello foo" "foo" "world"))
  (assert_not __LOC__ "a-b" "a_b")
  (assert_not __LOC__ "a-b" :a_b)
  (assert_ __LOC__ "a_b" :a_b)
  (assert_ __LOC__ {:a 1 :b 2 :c 3} (hash-map-from [:a 1 :b 2 :c 3]))
  (assert_ __LOC__ (count {:a 1 :b 2 :c 4}) (count (merge {:a 1 :b 3} {:b 2 :c 4})))
  (assert_ __LOC__ true (not= 1 2))
  (assert_ __LOC__ false (not= 1 1))
  (assert_ __LOC__ true (= 1 1))
  (assert_ __LOC__ false (= 1 2))
  (assert_ __LOC__ "12" (re-find (re-pattern "^\\d+") "12bb"))
  (assert_ __LOC__ nil (re-find (re-pattern "^\\d+$") "12bb"))
  (assert_ __LOC__ "1234" (re-find (re-pattern "^\\d+$") "1234"))
  (println  "1" "2")
  (eprintln "1" "2")
  (let t1 (println  "1" "2"))
  (let t2 (eprintln "1" "2"))
  (assert_ __LOC__ true (contains? {:a 1 :b 2} :b))
  (assert_ __LOC__ true (not (contains? {:a 1 :b 2} :c)))
  (assert_ __LOC__ true (vector? [1 2]))
  (assert_ __LOC__ 2 (second [1 2]))
  (assert_ __LOC__ true (string? ""))
  (assert_ __LOC__ true (boolean? false))
  (assert_ __LOC__ 6 (reduce (fn [^int a ^int b] (+ a b)) 0 [1 2 3]))
  (assert_ __LOC__ (str [1 2]) (str (vec (list 1 2))))
  (assert_ __LOC__ 2 (count (rest [1 2 3])))
  (assert_ __LOC__ true (string/starts-with? "abc" "ab"))
  (assert_ __LOC__ "Hello" (subs "Hello world" 0 5))
  (assert_ __LOC__ 5 (count "Hello"))
  (assert_ __LOC__ 42 (parse-int "42"))
  (assert_ __LOC__ 3 (last [1 2 3]))
  (assert_ __LOC__ (str ["a" "2" "c"]) (str (string/split "a 2 c" " ")))
  (assert_ __LOC__ "a b" (string/join " " ["a" "b"]))
  (assert_ __LOC__ 42 (:b (assoc {:a 1 :b 2 :c 3} :b 42)))
  (assert_ __LOC__ 99 (:d (assoc {:a 1} :d 99)))
  0)
