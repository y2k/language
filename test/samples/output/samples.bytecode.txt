=============================
(
+
1
2
)
=============================
(
=
1
2
)
=============================
(
conj
(
vector
1
2
)
3
)
=============================
(
def*
user/a
(
vector
1
2
)
)
=============================
(
def*
user/a
(
hash-map
1
2
)
)
=============================
(
do*
(
def*
user/a
1
)
a
)
=============================
(
def*
user/a
)
=============================
(
def*
user/f
(
fn*
(
p__1
x
p__2
)
x
)
)
=============================
(
def*
user/f
(
fn*
(
a
)
(
a
1
)
)
)
=============================
(
def*
user/foo
(
fn*
(
p__1
)
(
do*
(
let*
a
(
get
p__1
"b"
)
)
a
)
)
)
=============================
(
def*
user/foo
(
fn*
(
a
b
)
(
+
a
b
)
)
)
=============================
(
do*
(
def*
user/foo
(
fn*
(
a
b
)
(
+
a
b
)
)
)
(
def*
user/main
(
fn*
(
)
(
user/foo
1
2
)
)
)
)
=============================
(
do*
(
def*
user/foo
(
fn*
(
a
b
)
(
+
a
b
)
)
)
(
def*
user/main
(
fn*
(
x
)
(
user/foo
(
user/foo
1
2
)
x
)
)
)
)
=============================
(
do*
(
def*
user/foo
(
fn*
(
a
b
)
(
+
a
b
)
)
)
(
user/foo
1
2
)
)
=============================
(
if*
(
def*
user/foo
)
nil
(
def*
user/foo
3
)
)
=============================
(
do*
(
str
1
)
(
str
2
)
)
=============================
(
empty?
(
vector
)
)
=============================
2
=============================
3
=============================
0
=============================
1
=============================
"A-4-B"
=============================
(
vector
1
2
3
4
)
=============================
(
hash-map
"a"
1
"b"
2
)
=============================
(
get
(
vector
1
2
)
0
)
=============================
(
FIXME
)
=============================
(
gensym
)
=============================
(
if*
true
1
nil
)
=============================
(
do*
(
let*
p__1
1
)
(
if*
p__1
10
20
)
)
=============================
(
do*
(
let*
a
1
)
(
if*
a
(
do*
(
let*
b
2
)
(
if*
b
10
20
)
)
20
)
)
=============================
(
do*
(
let*
p__1
1
)
(
let*
a
(
get
p__1
0
)
)
a
)
=============================
(
do*
(
let*
a
1
)
a
)
=============================
(
do*
(
let*
fx
nil
)
(
fx
1
)
)
=============================
(
do*
(
let*
x
(
atom
0
)
)
x
)
=============================
(
list
1
2
3
)
=============================
(
not
(
=
1
2
)
)
=============================
(
do*
(
def*
lib/f
(
fn*
(
x
)
x
)
)
(
def*
lib/f
(
fn*
(
x
)
x
)
)
(
def*
bar/foo
(
fn*
(
)
(
lib/mb
1
2
)
(
lib/mf
3
4
)
)
)
)
=============================
(
do*
(
def*
lib/f
(
fn*
(
x
)
x
)
)
(
def*
bar/f
(
fn*
(
)
(
lib/a
1
)
)
)
)
=============================
(
do*
(
def*
lib/f
(
fn*
(
x
)
x
)
)
(
def*
bar/a
(
fn*
(
)
1
)
)
(
lib/f
(
bar/a
2
)
)
)
=============================
(
def*
bar/foo
(
fn*
(
a
b
)
(
+
a
b
)
)
)
=============================
(
println
1
nil
2
)
=============================
(
reduce
(
fn*
(
a
x
)
a
)
nil
(
vector
1
2
3
)
)
=============================
(
rest
(
vector
1
2
3
)
)
=============================
(
run!
(
fn*
(
x
)
1
)
(
vector
2
)
)
=============================
(
swap!
nil
(
fn*
(
x
)
x
)
)
=============================
(
vector
1
2
3
)
=============================
(
hash-map
"a"
1
"b"
2
)
=============================
(
hash-map
"k1"
1
"k2"
"v2"
"k3"
"v3"
)