(- 1 2)
(:a :b)
(:webview :env)
(.-length "")
(.foo :a :b 1)
(.join String "" [1 2 3])
(.run (m/foo))
(.run ^Runnable (m/foo))
(* :a :b)
(/ :a :b)
(^void fn [] (str :b :c))
(+ :a :b)
(+ 1 2)
(< :a :b)
(<= :a :b)
(= :a :b)
(> :a :b)
(>= :a :b)
(and (.foo nil) (.bar nil))
(and (.foo nil))
(and (not 1) (not (str 2)) (not 3))
(and (not 1) (not 2) (not 3))
(and 1 2 3)
(and 1)
(as 1 String)
(assoc {} :k :v)
(case 1 :a (count 2) (count 3))
(checked! (str))
(class foo.bar.Baz)
(class JobScheduler)
(comment (defn a [] 1) (defn b [] 2))
(concat [] [])
(concat [1 2] [3 4])
(conj [1 2] 3)
(contains? {:a 1 :b 2} :b)
(count {:f (fn [] (let [a 1] 2))})
(declare g) (def f (g 1))
(declare g) (defn f [] (g (fn [] 1)))
(declare g) (defn f [] (g ^Runnable (fn [] 1)))
(declare g) (defn f [] (g)) (defn g [] 0)
(def ^int LIMIT_CHARGE 80)
(def a (ClassLoader/getSystemClassLoader))
(def a nil)
(def f (m/g 1))
(def foo (atom {}))
(def foo (foo (foo 1)))
(def foo (foo 1))
(def foo 1)
(def LIMIT_CHARGE 80)
(def state (atom {:field 1}))
(def- a 2)(set! a.bar 1)
(def- LIMIT_CHARGE 80)
(defn ^String foo [^int a ^int b] a)
(defn ^void f [] (println "a"))
(defn a [] (str) (str) (str))
(defn a [] 1) (defn b [] 2)
(defn a [xs] (assoc xs :k :v))
(defn b [] (let [[^Aa a ^Bb b] :c] a))
(defn b [] (let [a :c] 0))
(defn b [] (let [a :c] a))
(defn c [] 3) (comment (defn a [] 1) (defn b [] 2)) (defn d [] 4)
(defn c [] 3) (defn d [] 4)
(defn f [_ x _] x)
(defn f [] (println "a"))
(defn f [a] (as a "String[]"))
(defn f [a] (as a String))
(defn foo [[a b]] (a b))
(defn foo [] (foo)(foo))
(defn foo [] (if true 1 2) (foo))
(defn foo [] (if true 2 3)(foo))
(defn foo [] (if true 2 3)(if false 4 5))
(defn foo [] (if true 2 3))
(defn foo [] (let [^Context wv (foo)] wv))
(defn foo [] (str) (println))
(defn foo [a b c] a)(foo :a :b 1)
(defn foo [a b] (a b))
(defn foo [a b] (foo (foo a b) (foo a b)))
(defn foo [a b] (foo (if true 2 3) (if true 6 7))(foo (if false 4 5) (if true 8 9)))
(defn foo [a b] (foo a b) (+ a b))
(defn foo [a] a)
(defn foo [x] (let [] (foo 1)(foo 2)))
(defn foo [x] (let [a (foo 1) b (foo 2)] (foo 3)(foo 4)))
(defn foo [xs] (let [[a] (rest xs)]) a)
(defn m [a] (.run ^Runnable (deref a)))
(defn- foo [a] a)
(defn- foo [context] (as (.getSySe context Ctx/AU_SE) String))
(do (str 1) (str 2))
(empty? [1 2])
(eval! (:b {:a 1 :b 2}))
(eval! (+ 1 2))
(eval! (if false 1 0))
(eval! (if true 1 0))
(eval! (str "A-" (+ 2 2) "-B"))
(eval! (vec (concat [1 2] [3 4])))
(eval! {:a 1 :b 2})
(fn [[a b]] (a b))
(fn [] (str :b :c))
(fn [x] (x 1))
(fn [x] x)
(fn! [] (str :b :c))
(Foo. :a :b 1)
(gen-class :name MainActivity :extends Activity :constructors {[] []} :prefix "a_" :methods [[^Override onCreate [Bundle int] void][^Override foo [] String]])
(gen-class :name MainActivity :extends Activity :constructors {[] []} :prefix "a_" :methods [[onCreate [Bundle int] void][foo [] String]])
(gensym)
(get :xs 1)
(if :a :b :c)
(if :a :b (println :c))
(if (if :a1 :a2 :a3) (if :b1 :b2 :b3) (if :c1 :c2 :c3))
(if false nil (throw (Exception. "foo")))
(if true 1)
(into-array [1 2 3])
(is 1 String)
(let [[_ _ a _] [1 2 3 4]] a)
(let [[a] :b] a)
(let [] (if true 1 2) (str))
(let [] (str) (println))
(let [^A a (str 1)] 2)
(let [^String a :b] a)
(let [a (:b :c)] a)
(let [a (.b :c 123)] (println "a") (str))
(let [a 1] (str) (str) (str))
(list 1)
(list? 1)
(map (fn [x] x) [1 2 3])
(map? 1)
(merge {:a 1} {:b 2})
(not true)
(not= :a :b)
(ns _ (:import [a.b List]))(def b (is :a List))
(ns _ (:import [b Context]))(def a Context/AUDIO_SERVICE)
(ns _ (:import [b Ctx]))(def a (str Ctx/A_S))
(ns b (:import [c An Cn Gn][d En Dn Fn])) (defn a [] (as 1 Cn) (as 2 Dn))
(ns gg.h7.i8 (:import [a.b C1 C2 C3] [d.e F4 F5 F6]))
(ns html)
(ns im.y2k.ch (:import [an.co Ctx AuMa]))
(ns im.y2k.chargetimer (:import [android.app Activity NotificationChannel]))(defn foo [x] x)
(or (.foo nil) (.bar nil))
(or (.foo nil))
(or (not 1) (not (println 2)) (not 3))
(or (not 1) (not 2) (not 3))
(or 1 2 3)
(or 1)
(println :a 1 "b")
(println (.-length ""))
(println (fn [[a]] a))
(println 1 (comment 3) 2)
(recover (fn [] 1) (fn [e] 2))
(reduce (fn [acc x] (+ acc x)) 0 (list 1 2 3))
(reduce (fn [acc x] (+ acc x)) 0 (vector 1 2 3))
(reduce (fn [acc x] (+ acc x)) 0 [1 2 3])
(rest [1 2 3])
(set! (.-length "") 1)
(set! (count 1) 2)
(set! 1 2)
(str :a "b" 3)
(str "Context/AUDIO_SERVICE")
(str (fn [[a b]] (= a b)))
(str (if :a :b :c))
(String/valueOf :level)
(swap! nil (fn [x] x))
(unescape "a\"b")
(vector? 1)
[(if true 1 2)]
[(str 1)]
[]
[1 2 3]
[1]
{:a :b :c :d}
{:a 1 :b 2}
{:fetch (fn [] (let [world 0] 1))}
nil
unit